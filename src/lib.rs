/// This is part of public interface so it's re-exported.
pub use tonic;

pub use error::ConnectError;
use error::InternalConnectError;
use rustls::crypto::CryptoProvider;
use std::path::{Path, PathBuf};
use std::str::FromStr;
use tonic::codegen::InterceptedService;
use tonic::transport::Uri;

type Service = InterceptedService<
    hyper_util::client::legacy::Client<
        hyper_rustls::HttpsConnector<hyper_util::client::legacy::connect::HttpConnector>,
        tonic::body::Body,
    >,
    MacaroonInterceptor,
>;

/// Convenience type alias for lightning client.
#[cfg(feature = "lightningrpc")]
pub type LightningClient = lnrpc::lightning_client::LightningClient<Service>;

/// Convenience type alias for wallet client.
#[cfg(feature = "walletrpc")]
pub type WalletKitClient = walletrpc::wallet_kit_client::WalletKitClient<Service>;

/// Convenience type alias for peers service client.
#[cfg(feature = "peersrpc")]
pub type PeersClient = peersrpc::peers_client::PeersClient<Service>;

/// Convenience type alias for versioner service client.
#[cfg(feature = "versionrpc")]
pub type VersionerClient = verrpc::versioner_client::VersionerClient<Service>;

/// Convenience type alias for signer client.
#[cfg(feature = "signrpc")]
pub type SignerClient = signrpc::signer_client::SignerClient<Service>;

/// Convenience type alias for router client.
#[cfg(feature = "routerrpc")]
pub type RouterClient = routerrpc::router_client::RouterClient<Service>;

/// Convenience type alias for invoices client.
#[cfg(feature = "invoicesrpc")]
pub type InvoicesClient = invoicesrpc::invoices_client::InvoicesClient<Service>;

/// Convenience type alias for state service client.
#[cfg(feature = "staterpc")]
pub type StateClient = staterpc::state_client::StateClient<Service>;

/// The client returned by `connect` function
///
/// This is a convenience type which you most likely want to use instead of raw client.
#[derive(Clone)]
pub struct Client {
    #[cfg(feature = "lightningrpc")]
    lightning: LightningClient,
    #[cfg(feature = "walletrpc")]
    wallet: WalletKitClient,
    #[cfg(feature = "signrpc")]
    signer: SignerClient,
    #[cfg(feature = "peersrpc")]
    peers: PeersClient,
    #[cfg(feature = "versionrpc")]
    version: VersionerClient,
    #[cfg(feature = "routerrpc")]
    router: RouterClient,
    #[cfg(feature = "invoicesrpc")]
    invoices: InvoicesClient,
    #[cfg(feature = "staterpc")]
    state: StateClient,
}

impl Client {
    /// Returns the lightning client.
    #[cfg(feature = "lightningrpc")]
    pub fn lightning(&mut self) -> &mut LightningClient {
        &mut self.lightning
    }

    /// Returns the wallet client.
    #[cfg(feature = "walletrpc")]
    pub fn wallet(&mut self) -> &mut WalletKitClient {
        &mut self.wallet
    }

    /// Returns the signer client.
    #[cfg(feature = "signrpc")]
    pub fn signer(&mut self) -> &mut SignerClient {
        &mut self.signer
    }

    /// Returns the versioner client.
    #[cfg(feature = "versionrpc")]
    pub fn versioner(&mut self) -> &mut VersionerClient {
        &mut self.version
    }

    /// Returns the peers client.
    #[cfg(feature = "peersrpc")]
    pub fn peers(&mut self) -> &mut PeersClient {
        &mut self.peers
    }

    /// Returns the router client.
    #[cfg(feature = "routerrpc")]
    pub fn router(&mut self) -> &mut RouterClient {
        &mut self.router
    }

    /// Returns the invoices client.
    #[cfg(feature = "invoicesrpc")]
    pub fn invoices(&mut self) -> &mut InvoicesClient {
        &mut self.invoices
    }

    /// Returns the state service client.
    #[cfg(feature = "staterpc")]
    pub fn state(&mut self) -> &mut StateClient {
        &mut self.state
    }
}

/// [`tonic::Status`] is re-exported as `Error` for convenience.
pub type Error = tonic::Status;

mod error;

/// Messages and other types generated by `tonic`/`prost`
///
/// This is the go-to module you will need to look in to find documentation on various message
/// types. However it may be better to start from methods on the [`LightningClient`](lnrpc::lightning_client::LightningClient) type.
#[cfg(feature = "lightningrpc")]
pub mod lnrpc {
    tonic::include_proto!("lnrpc");
}

#[cfg(feature = "walletrpc")]
pub mod walletrpc {
    tonic::include_proto!("walletrpc");
}

#[cfg(feature = "signrpc")]
pub mod signrpc {
    tonic::include_proto!("signrpc");
}

#[cfg(feature = "peersrpc")]
pub mod peersrpc {
    tonic::include_proto!("peersrpc");
}

#[cfg(feature = "routerrpc")]
pub mod routerrpc {
    tonic::include_proto!("routerrpc");
}

#[cfg(feature = "versionrpc")]
pub mod verrpc {
    tonic::include_proto!("verrpc");
}

#[cfg(feature = "invoicesrpc")]
pub mod invoicesrpc {
    tonic::include_proto!("invoicesrpc");
}

#[cfg(feature = "staterpc")]
pub mod staterpc {
    tonic::include_proto!("staterpc");
}

/// Supplies requests with macaroon
#[derive(Clone)]
pub struct MacaroonInterceptor {
    macaroon: String,
}

impl tonic::service::Interceptor for MacaroonInterceptor {
    fn call(&mut self, mut request: tonic::Request<()>) -> Result<tonic::Request<()>, Error> {
        request.metadata_mut().insert(
            "macaroon",
            tonic::metadata::MetadataValue::from_str(&self.macaroon)
                .expect("hex produced non-ascii"),
        );
        Ok(request)
    }
}

async fn load_macaroon(
    path: impl AsRef<Path> + Into<PathBuf>,
) -> Result<String, InternalConnectError> {
    let macaroon =
        tokio::fs::read(&path)
            .await
            .map_err(|error| InternalConnectError::ReadFile {
                file: path.into(),
                error,
            })?;
    Ok(hex::encode(macaroon))
}

/// Connects to LND using given address and credentials
///
/// This function does all required processing of the cert file and macaroon file, so that you
/// don't have to. The address must begin with "https://", though.
///
/// This is considered the recommended way to connect to LND. An alternative function to use
/// already-read certificate or macaroon data is currently **not** provided to discourage such use.
/// LND occasionally changes that data which would lead to errors and in turn in worse application.
///
/// If you have a motivating use case for use of direct data feel free to open an issue and
/// explain.
#[cfg_attr(feature = "tracing", tracing::instrument(name = "Connecting to LND"))]
pub async fn connect<CP, MP>(
    address: String,
    cert_file: CP,
    macaroon_file: MP,
) -> Result<Client, ConnectError>
where
    CP: AsRef<Path> + Into<PathBuf> + std::fmt::Debug,
    MP: AsRef<Path> + Into<PathBuf> + std::fmt::Debug,
{
    let macaroon = load_macaroon(macaroon_file).await?;
    let cert_path = cert_file.into();

    // install a default provider
    if CryptoProvider::get_default().is_none() {
        #[cfg(all(feature = "tls-aws-lc-rs", not(feature = "tls-ring")))]
        rustls::crypto::aws_lc_rs::default_provider()
            .install_default()
            .expect("Failed to install aws-lc-rs as the default crypto provider");
        #[cfg(all(feature = "tls-ring", not(feature = "tls-aws-lc-rs")))]
        rustls::crypto::ring::default_provider()
            .install_default()
            .expect("Failed to install ring as the default crypto provider");
    }

    let connector = hyper_rustls::HttpsConnectorBuilder::new()
        .with_tls_config(tls::config(&cert_path).await?)
        .https_or_http()
        .enable_http2()
        .build();

    let uri = Uri::from_str(&address).map_err(|e| InternalConnectError::InvalidAddress {
        address: address.to_string(),
        error: Box::new(e),
    })?;

    let client = hyper_util::client::legacy::Client::builder(hyper_util::rt::TokioExecutor::new())
        .http2_only(true)
        .build(connector);

    let svc = InterceptedService::new(client, MacaroonInterceptor { macaroon });

    let client = Client {
        #[cfg(feature = "lightningrpc")]
        lightning: lnrpc::lightning_client::LightningClient::with_origin(svc.clone(), uri.clone()),
        #[cfg(feature = "walletrpc")]
        wallet: walletrpc::wallet_kit_client::WalletKitClient::with_origin(
            svc.clone(),
            uri.clone(),
        ),
        #[cfg(feature = "peersrpc")]
        peers: peersrpc::peers_client::PeersClient::with_origin(svc.clone(), uri.clone()),
        #[cfg(feature = "signrpc")]
        signer: signrpc::signer_client::SignerClient::with_origin(svc.clone(), uri.clone()),
        #[cfg(feature = "versionrpc")]
        version: verrpc::versioner_client::VersionerClient::with_origin(svc.clone(), uri.clone()),
        #[cfg(feature = "routerrpc")]
        router: routerrpc::router_client::RouterClient::with_origin(svc.clone(), uri.clone()),
        #[cfg(feature = "invoicesrpc")]
        invoices: invoicesrpc::invoices_client::InvoicesClient::with_origin(
            svc.clone(),
            uri.clone(),
        ),
        #[cfg(feature = "staterpc")]
        state: staterpc::state_client::StateClient::with_origin(svc.clone(), uri.clone()),
    };
    Ok(client)
}

mod tls {
    use crate::error::{ConnectError, InternalConnectError};
    use rustls::client::danger::{HandshakeSignatureValid, ServerCertVerified, ServerCertVerifier};
    use rustls::crypto::{CryptoProvider, verify_tls12_signature, verify_tls13_signature};
    use rustls::pki_types::{CertificateDer, ServerName, UnixTime};
    use rustls::{
        CertificateError, DigitallySignedStruct, Error as TLSError, KeyLogFile, RootCertStore,
        SignatureScheme, client::ClientConfig,
    };
    use std::io::{BufReader, Error, ErrorKind};
    use std::{
        path::{Path, PathBuf},
        sync::Arc,
    };
    use webpki::anchor_from_trusted_cert;

    pub(crate) async fn config(
        path: impl AsRef<Path> + Into<PathBuf>,
    ) -> Result<ClientConfig, ConnectError> {
        let mut cfg = ClientConfig::builder()
            .dangerous()
            .with_custom_certificate_verifier(Arc::new(CertVerifier::load(path).await?))
            .with_no_client_auth();
        cfg.key_log = Arc::new(KeyLogFile::new());
        Ok(cfg)
    }

    #[derive(Debug)]
    pub(crate) struct CertVerifier {
        root_store: RootCertStore,
        provider: Arc<CryptoProvider>,
    }

    impl CertVerifier {
        pub(crate) async fn load(
            path: impl AsRef<Path> + Into<PathBuf>,
        ) -> Result<Self, InternalConnectError> {
            let path = path.into();
            let contents = match tokio::fs::read(&path).await {
                Ok(f) => f,
                Err(e) => {
                    return Err(InternalConnectError::ReadFile {
                        file: path.into(),
                        error: e,
                    });
                }
            };

            let mut store = RootCertStore::empty();
            let mut r = BufReader::new(contents.as_slice());
            for cert in rustls_pemfile::certs(&mut r as _) {
                match cert {
                    Ok(c) => {
                        store.add(c).map_err(|e| InternalConnectError::ParseCert {
                            file: path.clone(),
                            error: Box::new(e),
                        })?;
                    }
                    Err(e) => {
                        return Err(InternalConnectError::ParseCert {
                            file: path.clone(),
                            error: Box::new(e),
                        });
                    }
                }
            }

            let provider =
                CryptoProvider::get_default().ok_or(InternalConnectError::Other(Box::new(
                    Error::new(ErrorKind::Other, "CryptoProvider::get_default was missing"),
                )))?;

            Ok(CertVerifier {
                root_store: store,
                provider: provider.clone(),
            })
        }
    }

    impl ServerCertVerifier for CertVerifier {
        fn verify_server_cert(
            &self,
            end_entity: &CertificateDer<'_>,
            _intermediates: &[CertificateDer<'_>],
            _server_name: &ServerName<'_>,
            _ocsp_response: &[u8],
            _now: UnixTime,
        ) -> Result<ServerCertVerified, TLSError> {
            let end_trusted = anchor_from_trusted_cert(end_entity).map_err(|_| {
                TLSError::InvalidCertificate(CertificateError::ApplicationVerificationFailure)
            })?;
            for cert in &self.root_store.roots {
                if end_trusted == *cert {
                    return Ok(ServerCertVerified::assertion());
                }
            }
            Err(TLSError::InvalidCertificate(
                CertificateError::ApplicationVerificationFailure,
            ))
        }

        fn verify_tls12_signature(
            &self,
            message: &[u8],
            cert: &CertificateDer<'_>,
            dss: &DigitallySignedStruct,
        ) -> Result<HandshakeSignatureValid, TLSError> {
            verify_tls12_signature(
                message,
                cert,
                dss,
                &self.provider.signature_verification_algorithms,
            )
        }

        fn verify_tls13_signature(
            &self,
            message: &[u8],
            cert: &CertificateDer<'_>,
            dss: &DigitallySignedStruct,
        ) -> Result<HandshakeSignatureValid, TLSError> {
            verify_tls13_signature(
                message,
                cert,
                dss,
                &self.provider.signature_verification_algorithms,
            )
        }

        fn supported_verify_schemes(&self) -> Vec<SignatureScheme> {
            self.provider
                .signature_verification_algorithms
                .supported_schemes()
        }
    }
}
